<?php
/**
 * ContractsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  DCarbone\ParagonSolutionsPHPSDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PARAGON PAYMENT SOLUTIONS REST API
 *
 * <h2>Paragon Processing Platform</h2><p>This document is to provide a detailed description of how a developer or software solution provider can integrate with the Paragon Processing Platform (Paragon Platform).  <br>The Paragon Platform is for developers who wish to use Paragon's processing services within their software applications.  The Paragon Platform can stand alone as a web-based storefront with (or without) attached card readers or may be used in combination with point-of-sale (POS) and order entry applications.<br>The Paragon Platform accepts payments in many forms, including check, credit, debit, gift, loyalty and EBT cards. Payments may be taken online, over the telephone, from a mobile phone and at physical store locations. In addition to handling large volumes of payment transactions, the Paragon Platform manages and settles batches, protects sensitive card information, administers billing contracts and produces operational and analytical reports. </p><br><h2>Application Programming Interfaces (APIs)</h2><img src=\"../../Media/Images/Paragon_API_Communication.png\" alt=\"\" width=\"624\" height=\"242\"> <p>With our API, software systems and devices communicate with the Paragon Platform by exchanging messages.  <ol> <li>Client Application formulates a message and transmits the request to the Paragon Platform.</li> <li>The Paragon Platform translates the request and relays it to the Payment Processing Network.</li> <li>The Payment Processing Network processes the request and returns a response to the Paragon Platform.</li> <li>The Paragon Platform translates the response and relays it to the Client Application.</li></ol></p><br><h2>The Path to Integration </h2><img src=\"../../Media/Images/Paragon_Path_To_Integration.png\" alt=\"\" width=\"624\" height=\"258\"> <p><br><h3>Step 1: Open a Test Account </h3><p>Visit https://developer.paragonsolutions.com/testaccount to register for a free test account. Once registered you have instant access to your test account credentials and all the documentation you need to get started.  Head over to the library and make sure to check out all of our API's to learn about the Paragon Processing Platform transaction requests and responses.</p><br><h3>Step 2: Code & Certify</h3><p>Once in the Paragon Development portal, begin your certification or have an experienced Paragon integration specialist guide you through the testing process.  Once coding and testing are completed submit your request for certification.   Our team will then perform a detailed review of your integration to make sure your integration meets all your business requirements for success. </p><br><h3>Step 3: Go Live!</h3><p>After final review and testing your software solution is ready to begin taking live payments!  We know, an integration that is easy sounds too good to be true.  Don't take our word for it, start your integration today! </p><p><h3>Developer Notes</h3><ul><li>Install your development platform according to its product documentation.</li><li>Read through all the steps before you get started. We recommend reviewing the rest of this guide to familiarize yourself with the Paragon Processing Platform's terms, capabilities, web services and operations.</li></ul></p></p>
 *
 * The version of the OpenAPI document: 2.0
 * Contact: isvsupport@paragonsolutions.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace DCarbone\ParagonSolutionsPHPSDK\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use DCarbone\ParagonSolutionsPHPSDK\ApiException;
use DCarbone\ParagonSolutionsPHPSDK\Configuration;
use DCarbone\ParagonSolutionsPHPSDK\HeaderSelector;
use DCarbone\ParagonSolutionsPHPSDK\ObjectSerializer;

/**
 * ContractsApi Class Doc Comment
 *
 * @category Class
 * @package  DCarbone\ParagonSolutionsPHPSDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ContractsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation v2ContractsByContractKeyDelete
     *
     * Delete a Recurring Payment Agreement for a Customer.
     *
     * @param  string $contract_key contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts contracts (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse
     */
    public function v2ContractsByContractKeyDelete($contract_key, $authorization, $contracts)
    {
        list($response) = $this->v2ContractsByContractKeyDeleteWithHttpInfo($contract_key, $authorization, $contracts);
        return $response;
    }

    /**
     * Operation v2ContractsByContractKeyDeleteWithHttpInfo
     *
     * Delete a Recurring Payment Agreement for a Customer.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2ContractsByContractKeyDeleteWithHttpInfo($contract_key, $authorization, $contracts)
    {
        $request = $this->v2ContractsByContractKeyDeleteRequest($contract_key, $authorization, $contracts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2ContractsByContractKeyDeleteAsync
     *
     * Delete a Recurring Payment Agreement for a Customer.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyDeleteAsync($contract_key, $authorization, $contracts)
    {
        return $this->v2ContractsByContractKeyDeleteAsyncWithHttpInfo($contract_key, $authorization, $contracts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2ContractsByContractKeyDeleteAsyncWithHttpInfo
     *
     * Delete a Recurring Payment Agreement for a Customer.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyDeleteAsyncWithHttpInfo($contract_key, $authorization, $contracts)
    {
        $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
        $request = $this->v2ContractsByContractKeyDeleteRequest($contract_key, $authorization, $contracts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2ContractsByContractKeyDelete'
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2ContractsByContractKeyDeleteRequest($contract_key, $authorization, $contracts)
    {
        // verify the required parameter 'contract_key' is set
        if ($contract_key === null || (is_array($contract_key) && count($contract_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_key when calling v2ContractsByContractKeyDelete'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling v2ContractsByContractKeyDelete'
            );
        }
        // verify the required parameter 'contracts' is set
        if ($contracts === null || (is_array($contracts) && count($contracts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contracts when calling v2ContractsByContractKeyDelete'
            );
        }

        $resourcePath = '/v2/contracts/{contract_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($contract_key !== null) {
            $resourcePath = str_replace(
                '{' . 'contract_key' . '}',
                ObjectSerializer::toPathValue($contract_key),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($contracts)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($contracts));
            } else {
                $httpBody = $contracts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2ContractsByContractKeyGet
     *
     * Get a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel
     */
    public function v2ContractsByContractKeyGet($contract_key, $authorization)
    {
        list($response) = $this->v2ContractsByContractKeyGetWithHttpInfo($contract_key, $authorization);
        return $response;
    }

    /**
     * Operation v2ContractsByContractKeyGetWithHttpInfo
     *
     * Get a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2ContractsByContractKeyGetWithHttpInfo($contract_key, $authorization)
    {
        $request = $this->v2ContractsByContractKeyGetRequest($contract_key, $authorization);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2ContractsByContractKeyGetAsync
     *
     * Get a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyGetAsync($contract_key, $authorization)
    {
        return $this->v2ContractsByContractKeyGetAsyncWithHttpInfo($contract_key, $authorization)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2ContractsByContractKeyGetAsyncWithHttpInfo
     *
     * Get a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyGetAsyncWithHttpInfo($contract_key, $authorization)
    {
        $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\GetContractResponseModel';
        $request = $this->v2ContractsByContractKeyGetRequest($contract_key, $authorization);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2ContractsByContractKeyGet'
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2ContractsByContractKeyGetRequest($contract_key, $authorization)
    {
        // verify the required parameter 'contract_key' is set
        if ($contract_key === null || (is_array($contract_key) && count($contract_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_key when calling v2ContractsByContractKeyGet'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling v2ContractsByContractKeyGet'
            );
        }

        $resourcePath = '/v2/contracts/{contract_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($contract_key !== null) {
            $resourcePath = str_replace(
                '{' . 'contract_key' . '}',
                ObjectSerializer::toPathValue($contract_key),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2ContractsByContractKeyPatch
     *
     * Update the NextBillDate element of a Recurring Payment Agreement.
     *
     * @param  string $contract_key contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsNextBillDtModel $contracts_next_bill_date contracts_next_bill_date (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse
     */
    public function v2ContractsByContractKeyPatch($contract_key, $authorization, $contracts_next_bill_date)
    {
        list($response) = $this->v2ContractsByContractKeyPatchWithHttpInfo($contract_key, $authorization, $contracts_next_bill_date);
        return $response;
    }

    /**
     * Operation v2ContractsByContractKeyPatchWithHttpInfo
     *
     * Update the NextBillDate element of a Recurring Payment Agreement.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsNextBillDtModel $contracts_next_bill_date (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2ContractsByContractKeyPatchWithHttpInfo($contract_key, $authorization, $contracts_next_bill_date)
    {
        $request = $this->v2ContractsByContractKeyPatchRequest($contract_key, $authorization, $contracts_next_bill_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2ContractsByContractKeyPatchAsync
     *
     * Update the NextBillDate element of a Recurring Payment Agreement.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsNextBillDtModel $contracts_next_bill_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyPatchAsync($contract_key, $authorization, $contracts_next_bill_date)
    {
        return $this->v2ContractsByContractKeyPatchAsyncWithHttpInfo($contract_key, $authorization, $contracts_next_bill_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2ContractsByContractKeyPatchAsyncWithHttpInfo
     *
     * Update the NextBillDate element of a Recurring Payment Agreement.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsNextBillDtModel $contracts_next_bill_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyPatchAsyncWithHttpInfo($contract_key, $authorization, $contracts_next_bill_date)
    {
        $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
        $request = $this->v2ContractsByContractKeyPatchRequest($contract_key, $authorization, $contracts_next_bill_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2ContractsByContractKeyPatch'
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsNextBillDtModel $contracts_next_bill_date (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2ContractsByContractKeyPatchRequest($contract_key, $authorization, $contracts_next_bill_date)
    {
        // verify the required parameter 'contract_key' is set
        if ($contract_key === null || (is_array($contract_key) && count($contract_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_key when calling v2ContractsByContractKeyPatch'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling v2ContractsByContractKeyPatch'
            );
        }
        // verify the required parameter 'contracts_next_bill_date' is set
        if ($contracts_next_bill_date === null || (is_array($contracts_next_bill_date) && count($contracts_next_bill_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contracts_next_bill_date when calling v2ContractsByContractKeyPatch'
            );
        }

        $resourcePath = '/v2/contracts/{contract_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($contract_key !== null) {
            $resourcePath = str_replace(
                '{' . 'contract_key' . '}',
                ObjectSerializer::toPathValue($contract_key),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($contracts_next_bill_date)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($contracts_next_bill_date));
            } else {
                $httpBody = $contracts_next_bill_date;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2ContractsByContractKeyPut
     *
     * Update a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts contracts (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse
     */
    public function v2ContractsByContractKeyPut($contract_key, $authorization, $contracts)
    {
        list($response) = $this->v2ContractsByContractKeyPutWithHttpInfo($contract_key, $authorization, $contracts);
        return $response;
    }

    /**
     * Operation v2ContractsByContractKeyPutWithHttpInfo
     *
     * Update a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2ContractsByContractKeyPutWithHttpInfo($contract_key, $authorization, $contracts)
    {
        $request = $this->v2ContractsByContractKeyPutRequest($contract_key, $authorization, $contracts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2ContractsByContractKeyPutAsync
     *
     * Update a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyPutAsync($contract_key, $authorization, $contracts)
    {
        return $this->v2ContractsByContractKeyPutAsyncWithHttpInfo($contract_key, $authorization, $contracts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2ContractsByContractKeyPutAsyncWithHttpInfo
     *
     * Update a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsByContractKeyPutAsyncWithHttpInfo($contract_key, $authorization, $contracts)
    {
        $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
        $request = $this->v2ContractsByContractKeyPutRequest($contract_key, $authorization, $contracts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2ContractsByContractKeyPut'
     *
     * @param  string $contract_key (required)
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2ContractsByContractKeyPutRequest($contract_key, $authorization, $contracts)
    {
        // verify the required parameter 'contract_key' is set
        if ($contract_key === null || (is_array($contract_key) && count($contract_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contract_key when calling v2ContractsByContractKeyPut'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling v2ContractsByContractKeyPut'
            );
        }
        // verify the required parameter 'contracts' is set
        if ($contracts === null || (is_array($contracts) && count($contracts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contracts when calling v2ContractsByContractKeyPut'
            );
        }

        $resourcePath = '/v2/contracts/{contract_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($contract_key !== null) {
            $resourcePath = str_replace(
                '{' . 'contract_key' . '}',
                ObjectSerializer::toPathValue($contract_key),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($contracts)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($contracts));
            } else {
                $httpBody = $contracts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v2ContractsPost
     *
     * Add a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts contracts (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse
     */
    public function v2ContractsPost($authorization, $contracts)
    {
        list($response) = $this->v2ContractsPostWithHttpInfo($authorization, $contracts);
        return $response;
    }

    /**
     * Operation v2ContractsPostWithHttpInfo
     *
     * Add a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \DCarbone\ParagonSolutionsPHPSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v2ContractsPostWithHttpInfo($authorization, $contracts)
    {
        $request = $this->v2ContractsPostRequest($authorization, $contracts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v2ContractsPostAsync
     *
     * Add a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsPostAsync($authorization, $contracts)
    {
        return $this->v2ContractsPostAsyncWithHttpInfo($authorization, $contracts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v2ContractsPostAsyncWithHttpInfo
     *
     * Add a Recurring Payment Agreement for a Customer with a Payment Method from Card Safe.
     *
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v2ContractsPostAsyncWithHttpInfo($authorization, $contracts)
    {
        $returnType = '\DCarbone\ParagonSolutionsPHPSDK\Model\ContractsResponse';
        $request = $this->v2ContractsPostRequest($authorization, $contracts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v2ContractsPost'
     *
     * @param  string $authorization JWT security token obtained from Identity Server. (required)
     * @param  \DCarbone\ParagonSolutionsPHPSDK\Model\ContractsModel $contracts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v2ContractsPostRequest($authorization, $contracts)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling v2ContractsPost'
            );
        }
        // verify the required parameter 'contracts' is set
        if ($contracts === null || (is_array($contracts) && count($contracts) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $contracts when calling v2ContractsPost'
            );
        }

        $resourcePath = '/v2/contracts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml'],
                ['application/json', 'application/xml']
            );
        }

        // for model (json/xml)
        if (isset($contracts)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($contracts));
            } else {
                $httpBody = $contracts;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
