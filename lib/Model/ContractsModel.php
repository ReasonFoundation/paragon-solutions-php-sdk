<?php
/**
 * ContractsModel
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  DCarbone\ParagonSolutionsPHPSDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PARAGON PAYMENT SOLUTIONS REST API
 *
 * <h2>Paragon Processing Platform</h2><p>This document is to provide a detailed description of how a developer or software solution provider can integrate with the Paragon Processing Platform (Paragon Platform).  <br>The Paragon Platform is for developers who wish to use Paragon's processing services within their software applications.  The Paragon Platform can stand alone as a web-based storefront with (or without) attached card readers or may be used in combination with point-of-sale (POS) and order entry applications.<br>The Paragon Platform accepts payments in many forms, including check, credit, debit, gift, loyalty and EBT cards. Payments may be taken online, over the telephone, from a mobile phone and at physical store locations. In addition to handling large volumes of payment transactions, the Paragon Platform manages and settles batches, protects sensitive card information, administers billing contracts and produces operational and analytical reports. </p><br><h2>Application Programming Interfaces (APIs)</h2><img src=\"../../Media/Images/Paragon_API_Communication.png\" alt=\"\" width=\"624\" height=\"242\"> <p>With our API, software systems and devices communicate with the Paragon Platform by exchanging messages.  <ol> <li>Client Application formulates a message and transmits the request to the Paragon Platform.</li> <li>The Paragon Platform translates the request and relays it to the Payment Processing Network.</li> <li>The Payment Processing Network processes the request and returns a response to the Paragon Platform.</li> <li>The Paragon Platform translates the response and relays it to the Client Application.</li></ol></p><br><h2>The Path to Integration </h2><img src=\"../../Media/Images/Paragon_Path_To_Integration.png\" alt=\"\" width=\"624\" height=\"258\"> <p><br><h3>Step 1: Open a Test Account </h3><p>Visit https://developer.paragonsolutions.com/testaccount to register for a free test account. Once registered you have instant access to your test account credentials and all the documentation you need to get started.  Head over to the library and make sure to check out all of our API's to learn about the Paragon Processing Platform transaction requests and responses.</p><br><h3>Step 2: Code & Certify</h3><p>Once in the Paragon Development portal, begin your certification or have an experienced Paragon integration specialist guide you through the testing process.  Once coding and testing are completed submit your request for certification.   Our team will then perform a detailed review of your integration to make sure your integration meets all your business requirements for success. </p><br><h3>Step 3: Go Live!</h3><p>After final review and testing your software solution is ready to begin taking live payments!  We know, an integration that is easy sounds too good to be true.  Don't take our word for it, start your integration today! </p><p><h3>Developer Notes</h3><ul><li>Install your development platform according to its product documentation.</li><li>Read through all the steps before you get started. We recommend reviewing the rest of this guide to familiarize yourself with the Paragon Processing Platform's terms, capabilities, web services and operations.</li></ul></p></p>
 *
 * The version of the OpenAPI document: 2.0
 * Contact: isvsupport@paragonsolutions.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace DCarbone\ParagonSolutionsPHPSDK\Model;

use \ArrayAccess;
use \DCarbone\ParagonSolutionsPHPSDK\ObjectSerializer;

/**
 * ContractsModel Class Doc Comment
 *
 * @category Class
 * @package  DCarbone\ParagonSolutionsPHPSDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ContractsModel implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ContractsModel';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'customer_key' => 'string',
        'payment_info_key' => 'string',
        'payment_type' => 'string',
        'contract_id' => 'string',
        'contract_name' => 'string',
        'bill_amount' => 'string',
        'tax_amount' => 'string',
        'total_amount' => 'string',
        'start_date' => 'string',
        'end_date' => 'string',
        'next_bill_date' => 'string',
        'billing_period' => 'string',
        'billing_interval' => 'string',
        'max_failures' => 'string',
        'failure_interval' => 'string',
        'email_customer' => 'string',
        'email_merchant' => 'string',
        'email_customer_failure' => 'string',
        'email_merchant_failure' => 'string',
        'status' => 'string',
        'failure_retry_result_code' => 'string',
        'max_billing_cycle_retry' => 'string',
        'clone_tokens' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'customer_key' => null,
        'payment_info_key' => null,
        'payment_type' => null,
        'contract_id' => null,
        'contract_name' => null,
        'bill_amount' => null,
        'tax_amount' => null,
        'total_amount' => null,
        'start_date' => null,
        'end_date' => null,
        'next_bill_date' => null,
        'billing_period' => null,
        'billing_interval' => null,
        'max_failures' => null,
        'failure_interval' => null,
        'email_customer' => null,
        'email_merchant' => null,
        'email_customer_failure' => null,
        'email_merchant_failure' => null,
        'status' => null,
        'failure_retry_result_code' => null,
        'max_billing_cycle_retry' => null,
        'clone_tokens' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'customer_key' => 'customer_key',
        'payment_info_key' => 'payment_info_key',
        'payment_type' => 'payment_type',
        'contract_id' => 'contract_id',
        'contract_name' => 'contract_name',
        'bill_amount' => 'bill_amount',
        'tax_amount' => 'tax_amount',
        'total_amount' => 'total_amount',
        'start_date' => 'start_date',
        'end_date' => 'end_date',
        'next_bill_date' => 'next_bill_date',
        'billing_period' => 'billing_period',
        'billing_interval' => 'billing_interval',
        'max_failures' => 'max_failures',
        'failure_interval' => 'failure_interval',
        'email_customer' => 'email_customer',
        'email_merchant' => 'email_merchant',
        'email_customer_failure' => 'email_customer_failure',
        'email_merchant_failure' => 'email_merchant_failure',
        'status' => 'status',
        'failure_retry_result_code' => 'failure_retry_result_code',
        'max_billing_cycle_retry' => 'max_billing_cycle_retry',
        'clone_tokens' => 'clone_tokens'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'customer_key' => 'setCustomerKey',
        'payment_info_key' => 'setPaymentInfoKey',
        'payment_type' => 'setPaymentType',
        'contract_id' => 'setContractId',
        'contract_name' => 'setContractName',
        'bill_amount' => 'setBillAmount',
        'tax_amount' => 'setTaxAmount',
        'total_amount' => 'setTotalAmount',
        'start_date' => 'setStartDate',
        'end_date' => 'setEndDate',
        'next_bill_date' => 'setNextBillDate',
        'billing_period' => 'setBillingPeriod',
        'billing_interval' => 'setBillingInterval',
        'max_failures' => 'setMaxFailures',
        'failure_interval' => 'setFailureInterval',
        'email_customer' => 'setEmailCustomer',
        'email_merchant' => 'setEmailMerchant',
        'email_customer_failure' => 'setEmailCustomerFailure',
        'email_merchant_failure' => 'setEmailMerchantFailure',
        'status' => 'setStatus',
        'failure_retry_result_code' => 'setFailureRetryResultCode',
        'max_billing_cycle_retry' => 'setMaxBillingCycleRetry',
        'clone_tokens' => 'setCloneTokens'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'customer_key' => 'getCustomerKey',
        'payment_info_key' => 'getPaymentInfoKey',
        'payment_type' => 'getPaymentType',
        'contract_id' => 'getContractId',
        'contract_name' => 'getContractName',
        'bill_amount' => 'getBillAmount',
        'tax_amount' => 'getTaxAmount',
        'total_amount' => 'getTotalAmount',
        'start_date' => 'getStartDate',
        'end_date' => 'getEndDate',
        'next_bill_date' => 'getNextBillDate',
        'billing_period' => 'getBillingPeriod',
        'billing_interval' => 'getBillingInterval',
        'max_failures' => 'getMaxFailures',
        'failure_interval' => 'getFailureInterval',
        'email_customer' => 'getEmailCustomer',
        'email_merchant' => 'getEmailMerchant',
        'email_customer_failure' => 'getEmailCustomerFailure',
        'email_merchant_failure' => 'getEmailMerchantFailure',
        'status' => 'getStatus',
        'failure_retry_result_code' => 'getFailureRetryResultCode',
        'max_billing_cycle_retry' => 'getMaxBillingCycleRetry',
        'clone_tokens' => 'getCloneTokens'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['customer_key'] = $data['customer_key'] ?? null;
        $this->container['payment_info_key'] = $data['payment_info_key'] ?? null;
        $this->container['payment_type'] = $data['payment_type'] ?? null;
        $this->container['contract_id'] = $data['contract_id'] ?? null;
        $this->container['contract_name'] = $data['contract_name'] ?? null;
        $this->container['bill_amount'] = $data['bill_amount'] ?? null;
        $this->container['tax_amount'] = $data['tax_amount'] ?? null;
        $this->container['total_amount'] = $data['total_amount'] ?? null;
        $this->container['start_date'] = $data['start_date'] ?? null;
        $this->container['end_date'] = $data['end_date'] ?? null;
        $this->container['next_bill_date'] = $data['next_bill_date'] ?? null;
        $this->container['billing_period'] = $data['billing_period'] ?? null;
        $this->container['billing_interval'] = $data['billing_interval'] ?? null;
        $this->container['max_failures'] = $data['max_failures'] ?? null;
        $this->container['failure_interval'] = $data['failure_interval'] ?? null;
        $this->container['email_customer'] = $data['email_customer'] ?? null;
        $this->container['email_merchant'] = $data['email_merchant'] ?? null;
        $this->container['email_customer_failure'] = $data['email_customer_failure'] ?? null;
        $this->container['email_merchant_failure'] = $data['email_merchant_failure'] ?? null;
        $this->container['status'] = $data['status'] ?? null;
        $this->container['failure_retry_result_code'] = $data['failure_retry_result_code'] ?? null;
        $this->container['max_billing_cycle_retry'] = $data['max_billing_cycle_retry'] ?? null;
        $this->container['clone_tokens'] = $data['clone_tokens'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets customer_key
     *
     * @return string|null
     */
    public function getCustomerKey()
    {
        return $this->container['customer_key'];
    }

    /**
     * Sets customer_key
     *
     * @param string|null $customer_key Unique identifier for Customer assigned by Paragon platform
     *
     * @return self
     */
    public function setCustomerKey($customer_key)
    {
        $this->container['customer_key'] = $customer_key;

        return $this;
    }

    /**
     * Gets payment_info_key
     *
     * @return string|null
     */
    public function getPaymentInfoKey()
    {
        return $this->container['payment_info_key'];
    }

    /**
     * Sets payment_info_key
     *
     * @param string|null $payment_info_key Unique Identifier assigned to a Checking Account or Credit Card payment method(by Paragon platform).  Required for TransType= ADD and UPDATE;  Not used for TransType =DELETE
     *
     * @return self
     */
    public function setPaymentInfoKey($payment_info_key)
    {
        $this->container['payment_info_key'] = $payment_info_key;

        return $this;
    }

    /**
     * Gets payment_type
     *
     * @return string|null
     */
    public function getPaymentType()
    {
        return $this->container['payment_type'];
    }

    /**
     * Sets payment_type
     *
     * @param string|null $payment_type Type of payment for method (CC - Credit Card, CK - Check).  Required for TransType= ADD and UPDATE;  Not used for TransType =DELETE.
     *
     * @return self
     */
    public function setPaymentType($payment_type)
    {
        $this->container['payment_type'] = $payment_type;

        return $this;
    }

    /**
     * Gets contract_id
     *
     * @return string|null
     */
    public function getContractId()
    {
        return $this->container['contract_id'];
    }

    /**
     * Sets contract_id
     *
     * @param string|null $contract_id Unique identifier assigned by Merchant to the Recurring Payment Agreement between Merchant and Customer.  Required for TransType = ADD and UPDATE;  Not used for TransType = DELETE.
     *
     * @return self
     */
    public function setContractId($contract_id)
    {
        $this->container['contract_id'] = $contract_id;

        return $this;
    }

    /**
     * Gets contract_name
     *
     * @return string|null
     */
    public function getContractName()
    {
        return $this->container['contract_name'];
    }

    /**
     * Sets contract_name
     *
     * @param string|null $contract_name Description for Recurring Payment Agreement
     *
     * @return self
     */
    public function setContractName($contract_name)
    {
        $this->container['contract_name'] = $contract_name;

        return $this;
    }

    /**
     * Gets bill_amount
     *
     * @return string|null
     */
    public function getBillAmount()
    {
        return $this->container['bill_amount'];
    }

    /**
     * Sets bill_amount
     *
     * @param string|null $bill_amount Sales amount for each recurring payment.  Required for TransType = ADD and UPDATE;  Not used for TransType = DELETE.
     *
     * @return self
     */
    public function setBillAmount($bill_amount)
    {
        $this->container['bill_amount'] = $bill_amount;

        return $this;
    }

    /**
     * Gets tax_amount
     *
     * @return string|null
     */
    public function getTaxAmount()
    {
        return $this->container['tax_amount'];
    }

    /**
     * Sets tax_amount
     *
     * @param string|null $tax_amount Tax amount (for each payment)
     *
     * @return self
     */
    public function setTaxAmount($tax_amount)
    {
        $this->container['tax_amount'] = $tax_amount;

        return $this;
    }

    /**
     * Gets total_amount
     *
     * @return string|null
     */
    public function getTotalAmount()
    {
        return $this->container['total_amount'];
    }

    /**
     * Sets total_amount
     *
     * @param string|null $total_amount Total (Sales + Tax) amount (for each payment).  Required for TransType = ADD and UPDATE;  Not used for TransType = DELETE.
     *
     * @return self
     */
    public function setTotalAmount($total_amount)
    {
        $this->container['total_amount'] = $total_amount;

        return $this;
    }

    /**
     * Gets start_date
     *
     * @return string|null
     */
    public function getStartDate()
    {
        return $this->container['start_date'];
    }

    /**
     * Sets start_date
     *
     * @param string|null $start_date Date of first payment (MM/DD/YYYY).  Required for TransType = ADD and UPDATE;  Optional for TransType = DELETE.
     *
     * @return self
     */
    public function setStartDate($start_date)
    {
        $this->container['start_date'] = $start_date;

        return $this;
    }

    /**
     * Gets end_date
     *
     * @return string|null
     */
    public function getEndDate()
    {
        return $this->container['end_date'];
    }

    /**
     * Sets end_date
     *
     * @param string|null $end_date Date of termination for Recurring Payment Agreement(MM/DD/YYYY).  Optional for TransType = ADD and UPDATE;  Not used for TransType = DELETE.
     *
     * @return self
     */
    public function setEndDate($end_date)
    {
        $this->container['end_date'] = $end_date;

        return $this;
    }

    /**
     * Gets next_bill_date
     *
     * @return string|null
     */
    public function getNextBillDate()
    {
        return $this->container['next_bill_date'];
    }

    /**
     * Sets next_bill_date
     *
     * @param string|null $next_bill_date Date of first payment (MM/DD/YYYY).  Required for TransType = ADD and UPDATE;  Not used for TransType = DELETE.
     *
     * @return self
     */
    public function setNextBillDate($next_bill_date)
    {
        $this->container['next_bill_date'] = $next_bill_date;

        return $this;
    }

    /**
     * Gets billing_period
     *
     * @return string|null
     */
    public function getBillingPeriod()
    {
        return $this->container['billing_period'];
    }

    /**
     * Sets billing_period
     *
     * @param string|null $billing_period Unit (DAY, WEEK, MONTH, YEAR) for billing time period.  Required for TransType = ADD and UPDATE;  Not used for TransType = DELETE.  Note that the minimum BillingPeriod for FirstACH is WEEK
     *
     * @return self
     */
    public function setBillingPeriod($billing_period)
    {
        $this->container['billing_period'] = $billing_period;

        return $this;
    }

    /**
     * Gets billing_interval
     *
     * @return string|null
     */
    public function getBillingInterval()
    {
        return $this->container['billing_interval'];
    }

    /**
     * Sets billing_interval
     *
     * @param string|null $billing_interval Number of periods (1, 2, 4, 14, 21, 28) between payments - used in combination with BillingPeriod.  Required for TransType= ADD and UPDATE;  Not used for TransType = DELETE.
     *
     * @return self
     */
    public function setBillingInterval($billing_interval)
    {
        $this->container['billing_interval'] = $billing_interval;

        return $this;
    }

    /**
     * Gets max_failures
     *
     * @return string|null
     */
    public function getMaxFailures()
    {
        return $this->container['max_failures'];
    }

    /**
     * Sets max_failures
     *
     * @param string|null $max_failures Maximum number (0-10) of attempts for Paragon platform to reprocess failed payments.  The value of MaxFailures treated as zero if no value is provided for Recurring Payment Agreement.
     *
     * @return self
     */
    public function setMaxFailures($max_failures)
    {
        $this->container['max_failures'] = $max_failures;

        return $this;
    }

    /**
     * Gets failure_interval
     *
     * @return string|null
     */
    public function getFailureInterval()
    {
        return $this->container['failure_interval'];
    }

    /**
     * Sets failure_interval
     *
     * @param string|null $failure_interval Indicates the interval (1-28) after which the failed payment will be retied.  The value of FailureInterval treated as one if no value is provided for Recurring Payment Agreement.
     *
     * @return self
     */
    public function setFailureInterval($failure_interval)
    {
        $this->container['failure_interval'] = $failure_interval;

        return $this;
    }

    /**
     * Gets email_customer
     *
     * @return string|null
     */
    public function getEmailCustomer()
    {
        return $this->container['email_customer'];
    }

    /**
     * Sets email_customer
     *
     * @param string|null $email_customer Send (TRUE) electronic mail message to Customer when an attempted payment is successful.
     *
     * @return self
     */
    public function setEmailCustomer($email_customer)
    {
        $this->container['email_customer'] = $email_customer;

        return $this;
    }

    /**
     * Gets email_merchant
     *
     * @return string|null
     */
    public function getEmailMerchant()
    {
        return $this->container['email_merchant'];
    }

    /**
     * Sets email_merchant
     *
     * @param string|null $email_merchant Send (TRUE) electronic mail message to Merchant when an attempted payment is successful.
     *
     * @return self
     */
    public function setEmailMerchant($email_merchant)
    {
        $this->container['email_merchant'] = $email_merchant;

        return $this;
    }

    /**
     * Gets email_customer_failure
     *
     * @return string|null
     */
    public function getEmailCustomerFailure()
    {
        return $this->container['email_customer_failure'];
    }

    /**
     * Sets email_customer_failure
     *
     * @param string|null $email_customer_failure Send (TRUE) electronic mail message to Merchant when an attempted payment is unsuccessful.
     *
     * @return self
     */
    public function setEmailCustomerFailure($email_customer_failure)
    {
        $this->container['email_customer_failure'] = $email_customer_failure;

        return $this;
    }

    /**
     * Gets email_merchant_failure
     *
     * @return string|null
     */
    public function getEmailMerchantFailure()
    {
        return $this->container['email_merchant_failure'];
    }

    /**
     * Sets email_merchant_failure
     *
     * @param string|null $email_merchant_failure Send (True) electronic mail message to Merchant when an attempted payment is unsuccessful.
     *
     * @return self
     */
    public function setEmailMerchantFailure($email_merchant_failure)
    {
        $this->container['email_merchant_failure'] = $email_merchant_failure;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status Paragon platform to evaluate Recurring Payment Agreement each day to determine whether(ACTIVE) or not (INACTIVE, CLOSED) a payment to be processed or reprocessed(PENDING).
     *
     * @return self
     */
    public function setStatus($status)
    {
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets failure_retry_result_code
     *
     * @return string|null
     */
    public function getFailureRetryResultCode()
    {
        return $this->container['failure_retry_result_code'];
    }

    /**
     * Sets failure_retry_result_code
     *
     * @param string|null $failure_retry_result_code Collection of result code values from unsuccessful payment attempts for Paragon platform to reprocess automatically.
     *
     * @return self
     */
    public function setFailureRetryResultCode($failure_retry_result_code)
    {
        $this->container['failure_retry_result_code'] = $failure_retry_result_code;

        return $this;
    }

    /**
     * Gets max_billing_cycle_retry
     *
     * @return string|null
     */
    public function getMaxBillingCycleRetry()
    {
        return $this->container['max_billing_cycle_retry'];
    }

    /**
     * Sets max_billing_cycle_retry
     *
     * @param string|null $max_billing_cycle_retry The number of times a suspended contract will be reconsidered for activation by Paragon platform.
     *
     * @return self
     */
    public function setMaxBillingCycleRetry($max_billing_cycle_retry)
    {
        $this->container['max_billing_cycle_retry'] = $max_billing_cycle_retry;

        return $this;
    }

    /**
     * Gets clone_tokens
     *
     * @return string|null
     */
    public function getCloneTokens()
    {
        return $this->container['clone_tokens'];
    }

    /**
     * Sets clone_tokens
     *
     * @param string|null $clone_tokens Use this tag with value of TRUE only when Token Sharing is enabled for the reseller and the Merchant wants to clone the customer and payment information to create the contract.
     *
     * @return self
     */
    public function setCloneTokens($clone_tokens)
    {
        $this->container['clone_tokens'] = $clone_tokens;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


